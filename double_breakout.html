<html>
<head>
    <title>double_breakout</title>
    <script src="processing-1.4.8.min.js"></script>
</head>
<body>
    <center><h1>double_breakout</h1>
    <p>Sketch rendered with Processing.js.</p>
    <script type="text/processing" data-processing-target="processing-canvas">
    /**  
    * A Simple Solar System Animation
    * @author Charles Jin
    * @version 1.0 
    * Copyright 2017
    */ 
    
    float screen_width = 1200;
    float screen_height = 1000;
    
    ArrayList<Brick> bricks = new ArrayList<Brick>(); 
    
    boolean keyA = false;
    boolean keyD = false;
    //Brick b = new Brick(10, 20);
    Ball ball = new Ball(80, -300);
    Paddle paddle = new Paddle(-65, -screen_height/2+20); 
    Stage stage = new Stage(screen_width, screen_height);
    
    
    void setup() {
      size(1200, 1000); // Set window dimensions.
      //pixelDensity(2); // Turn on retina mode for retina screens. Doesn't work with Processing.js
      create_bricks();
      
    }
    
    void draw() {
      background(#000000);
      fill(#FFFFFF);
      ball.move();
      paddle._draw();
      draw_bricks();
      //move_paddle();
      paddle.move();
    
      
      ball._draw();
      ball.bounce_ball(stage, bricks);
      }
    
    // allow user to hold down key for repetitive actions
    void keyPressed()
    {
      if (key == 'a') { keyA = true; }   //paddle.move(-10);
      if (key == 'd') { keyD = true; }  
      
    }
    
    void keyReleased(){
      if (key == 'a') { keyA = false; }
      if (key == 'd') { keyD = false; }
    }
    
    //void move_paddle(){
    //  paddle.move();
    //}
    
    class Ball {
      float x, y; 
      float w = 30; 
      float h = 30;
      float r;
      float xd = 4;
      float yd = 3.2;
      color c = #FFFFFF;
      float gameoverx = -450; // coordinates for the "Game Over" text.
      float gameovery = -50;
    
      Ball(float x, float y) {
        this.x = x;
        this.y = y;
        this.r = h/2;
      } 
    
      void move() {
        this.x += this.xd;
        this.y += this.yd;
      }
    
      void _draw() {
        fill(c);
        ellipse(cx(x), cy(y), w, h);
      }
    
      void detect_hline(float y) {
        if (y < this.y) {
          this.yd = this.yd * -1;
        }
      }
    
      void bounce_ball(Stage s, ArrayList<Brick> bs) {
        h_wall_bounce(s);
        v_wall_bounce(s);
        paddle_bounce(paddle);
        for (int i = 0; i < bs.size(); i++) {
          h_brick_wall_bounce(bs.get(i));
          v_brick_wall_bounce(bs.get(i));
        }
      }
    
      void h_wall_bounce(Stage s) {
        boolean hit_ceiling = ball_line(this.x, this.y, this.r, s.ulx, s.uly, s.urx, s.ury);
        boolean hit_floor = ball_line(this.x, this.y, this.r, s.llx, s.lly, s.lrx, s.lry);
    
        if (hit_ceiling || hit_floor) {
          this.yd = this.yd * -1;
          game_over();
        }
      }
    
      void v_wall_bounce(Stage s) {
        boolean hit_leftwall = ball_line(this.x, this.y, this.r, s.ulx, s.uly, s.llx, s.lly);
        boolean hit_rightwall = ball_line(this.x, this.y, this.r, s.urx, s.ury, s.lrx, s.lry);
    
        if (hit_leftwall || hit_rightwall) {
          this.xd = this.xd * -1;
        }
      }
    
      void h_brick_wall_bounce(Brick b) {
        if (b.visible) {
          boolean hit_top_wall = ball_line(this.x, this.y, this.r, b.ulx, b.uly, b.urx, b.ury);
          boolean hit_bottom_wall = ball_line(this.x, this.y, this.r, b.llx, b.lly, b.lrx, b.lry);
    
          if (hit_top_wall || hit_bottom_wall) {
            this.yd = this.yd * -1;
            b.visible = false;
          }
        }
      }
    
      void v_brick_wall_bounce(Brick b) {
        if (b.visible) {
          boolean hit_left_wall = ball_line(this.x, this.y, this.r, b.ulx, b.uly, b.llx, b.lly);
          boolean hit_right_wall = ball_line(this.x, this.y, this.r, b.urx, b.ury, b.lrx, b.lry);
    
          if (hit_left_wall || hit_right_wall) {
            this.xd = this.xd * -1;
            b.visible = false;
          }
        }
      }
    
      void paddle_bounce(Paddle p) {
    
        boolean hit_top_wall = ball_line(this.x, this.y, this.r, p.ulx, p.uly, p.urx, p.ury);
    
        if (hit_top_wall) {
          this.yd = this.yd * -1;
        }
      }
    
      void game_over() {
        textSize(160);
        fill(#CECCCC);
        text("GAME OVER", cx(gameoverx-2), cy(gameovery-2));
        text("GAME OVER", cx(gameoverx+2), cy(gameovery+2));
        text("GAME OVER", cx(gameoverx-2), cy(gameovery+2));
        text("GAME OVER", cx(gameoverx+2), cy(gameovery-2));
        fill(#FFFFFF);
        text("GAME OVER", cx(gameoverx), cy(gameovery));
        paddle.spd = 0;
        xd = 0;
        yd = 0;
      }
    }
    
    class Brick {
      float x, y; 
      float w = 100; 
      float h = 50;
      color c;
      float ulx, uly; //Corners of the brick. 
      float urx, ury;
      float llx, lly;
      float lrx, lry;
      boolean visible = true;
    
      Brick(float x, float y, color c) {
        this.x = x;
        this.y = y; // x = 0, y = 0  
        this.ulx = x;
        this.uly = y;
        this.urx = x+w;
        this.ury = y;
        this.llx = x;
        this.lly = y-h;
        this.lrx = x+w;
        this.lry = y-h;
        this.c = c;
      } 
    
      void _draw() {
        if (visible) {
          fill(this.c);
          rect(cx(x), cy(y), w, h);
          //ellipse(cx(lrx), cy(lry), 20, 20);
        }
      }
    
      void highlight_corners() {
        // draw circles on the corners of the brick to help with debugging.
        fill(#FF6C6C);
        ellipse(cx(ulx), cy(uly), 20, 20);
        ellipse(cx(urx), cy(ury), 20, 20);
        ellipse(cx(llx), cy(lly), 20, 20);
        ellipse(cx(lrx), cy(lry), 20, 20);
      }
    }
    
    void create_bricks() {
      // initialize bricks with different color for each layer.
      for (int i = -6; i < 5; i++) { //creates 7
        bricks.add(new Brick(i*100+50, -50, #ffb3ba)); //Pastel red
        bricks.add(new Brick(i*100+50, 0, #ffdfba)); //Pastel orange
        bricks.add(new Brick(i*100+50, 50, #ffffba)); //Pastel yellow
        bricks.add(new Brick(i*100+50, 100, #baffc9)); //Pastel green
        bricks.add(new Brick(i*100+50, 150, #bae1ff)); //Pastel blue
    
      }
    }
    
    void draw_bricks() {
      for (int i = 0; i < bricks.size(); i++) {
        bricks.get(i)._draw();
      }
    }
    
    class Paddle {
      float w = 130;
      float h = 10;
      float x, y;
      float ulx, uly; //Corners of the paddle. 
      float urx, ury;
      float llx, lly;
      float lrx, lry;
      float spd = 10;
    
      Paddle(float x, float y) {
        this.x = x;
        this.y = y;
        this.ulx = x;
        this.uly = y;
        this.urx = x+w;
        this.ury = y;
        this.llx = x;
        this.lly = y-h;
        this.lrx = x+w;
        this.lry = y-h;
      }
    
      void _draw()
      {
        rect(cx(x), cy(y), w, h);
      }
      void move()
      {
        if (keyA) {
          move_paddle(-this.spd);
        }
        if (keyD) {
          move_paddle(this.spd);
        }
      }
    
      void move_paddle(float n) {
        this.x += n;
        this.ulx += n;
        this.urx += n;
        this.llx += n;
        this.lrx += n;
    
      }
    }
    
    class Stage {
      float ulx, uly;
      float urx, ury;
      float llx, lly;
      float lrx, lry;
      
      Stage(float sw, float sh) {
        this.ulx = -sw/2;
        this.uly = sh/2;
        this.urx = sw/2;
        this.ury = sh/2;
        this.llx = -sw/2;
        this.lly = -sh/2;
        this.lrx = sw/2;
        this.lry = -sh/2;
      }
    }
    
    boolean ball_line(float bx, float by, float r, float lx1, float ly1, float lx2, float ly2) {
      // Circle-line segment collision detection algorithm by bobobobo on StackOverflow: https://stackoverflow.com/a/1084899
      float dx = lx2 - lx1;
      float dy = ly2 - ly1;
      float fx = lx1 - bx;
      float fy = ly1 - by;
      float a = dx*dx + dy*dy;
      float b = 2*(fx*dx + fy*dy);
      float c = (fx*fx + fy*fy) - r*r;
      float discriminant = b*b-4*a*c;
      
      if (discriminant < 0)
        {
          // no intersection
        }
      else
      {
        discriminant = sqrt(discriminant);
        float t1 = (-b - discriminant)/(2*a);
        float t2 = (-b + discriminant)/(2*a);
        
        if (t1 >= 0 && t1 <= 1){
          return true;
        }
        if (t2 >= 0 && t2 <= 1)
        {
          return true;
        }
      }
      return false;
    }
    
    void draw_circle(float x, float y) {
      // Draw a red circle at the specified coordinate.
      fill(#ffb3ba);
      ellipse(cx(x), cy(y), 20, 20);
    }
    
    float cx (float x) {
      //convert processing y coors to cartesian coors
      return (screen_width/2 + x);
    }
      
    float cy(float y){
      //convert processing x coors to cartesian coors
      return (screen_height/2 - y);
    }
    
    float ucx(float x){
      //convert y coors to from cartesian to processing coors
      return (x - screen_width/2);
    }
    
    float ucy(float y){
      //convert y coors from cartesian to processing coors
      return (screen_height/2 - y);
    }
    </script>

    <canvas id="processing-canvas"> </canvas></center>
    <center>
    <p><b>Instructions:</b></p>
    <p>Use the 'a' key to move the paddle left, and the 'd' key to move the paddle right.</p>
    </center>
</body>
</html>
